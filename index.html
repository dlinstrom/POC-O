<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flash Flood Watch POC</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
background: linear-gradient(135deg, #2d5016 0%, #68a225 100%);
min-height: 100vh;
padding: 10px;
-webkit-text-size-adjust: 100%;
-webkit-font-smoothing: antialiased;
}
@media (min-width: 768px) {
body {
padding: 20px;
}
}
.container {
background: rgba(255, 255, 255, 0.95);
border-radius: 15px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
padding: 15px;
max-width: 1400px;
margin: 0 auto;
}
@media (min-width: 768px) {
.container {
border-radius: 20px;
padding: 30px;
}
}
h1 {
color: #333;
text-align: center;
margin-bottom: 15px;
font-size: 1.8em;
line-height: 1.2;
}
@media (min-width: 768px) {
h1 {
font-size: 2.2em;
margin-bottom: 20px;
}
}
.status {
text-align: center;
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
font-weight: 600;
font-size: 14px;
}
@media (min-width: 768px) {
.status {
padding: 10px;
margin-bottom: 20px;
font-size: 16px;
}
}
.loading-notice, .info-notice, .error-notice {
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
text-align: center;
font-size: 14px;
}
@media (min-width: 768px) {
.loading-notice, .info-notice, .error-notice {
padding: 15px;
margin-bottom: 20px;
font-size: 16px;
}
}
.loading-notice {
background: #d1ecf1;
color: #0c5460;
}
.config-section {
background: #f8f9fa;
border-radius: 10px;
padding: 15px;
margin-bottom: 15px;
}
@media (min-width: 768px) {
.config-section {
padding: 20px;
margin-bottom: 20px;
}
}
.config-section h3 {
margin-bottom: 12px;
color: #333;
font-size: 1.1em;
}
@media (min-width: 768px) {
.config-section h3 {
margin-bottom: 15px;
font-size: 1.2em;
}
}
.config-grid {
display: grid;
grid-template-columns: 1fr;
gap: 8px;
margin-bottom: 12px;
}
@media (min-width: 480px) {
.config-grid {
grid-template-columns: repeat(2, 1fr);
gap: 10px;
}
}
@media (min-width: 768px) {
.config-grid {
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
margin-bottom: 15px;
}
}
input, select {
width: 100%;
padding: 12px;
border: 2px solid #ddd;
border-radius: 8px;
font-size: 16px;
-webkit-appearance: none;
appearance: none;
}
@media (min-width: 768px) {
input, select {
padding: 10px;
border-radius: 5px;
font-size: 14px;
}
}
input:focus, select:focus {
outline: none;
border-color: #4a7c28;
box-shadow: 0 0 0 3px rgba(74, 124, 40, 0.1);
}
.button-group {
display: flex;
gap: 8px;
flex-wrap: wrap;
}
@media (min-width: 768px) {
.button-group {
gap: 10px;
}
}
button {
background: linear-gradient(135deg, #4a7c28 0%, #68a225 100%);
color: white;
border: none;
padding: 12px 16px;
border-radius: 8px;
font-size: 14px;
font-weight: 600;
cursor: pointer;
transition: transform 0.2s;
min-height: 44px;
flex: 1;
min-width: 120px;
}
@media (min-width: 768px) {
button {
padding: 10px 20px;
border-radius: 5px;
min-height: auto;
flex: initial;
min-width: auto;
}
}
button:hover:not(:disabled) {
transform: scale(1.02);
}
@media (min-width: 768px) {
button:hover:not(:disabled) {
transform: scale(1.05);
}
}
button:active {
transform: scale(0.98);
}
.status.connected {
background: #d4f4dd;
color: #2d5016;
}
.status.disconnected {
background: #f8d7da;
color: #721c24;
}
.status.connecting {
background: #fff3cd;
color: #856404;
}
button:disabled {
opacity: 0.5;
cursor: not-allowed;
}
.preset-btn {
background: white;
color: #4a7c28;
border: 2px solid #4a7c28;
}
.preset-btn:hover {
background: #4a7c28;
color: white;
}
.export-btn {
background: linear-gradient(135deg, #2d5016 0%, #5cb85c 100%);
}
.clear-btn {
background: linear-gradient(135deg, #8b6f47 0%, #b8a074 100%);
}
.stats-grid {
display: grid;
grid-template-columns: 1fr;
gap: 10px;
margin-bottom: 15px;
}
@media (min-width: 480px) {
.stats-grid {
grid-template-columns: repeat(2, 1fr);
}
}
@media (min-width: 768px) {
.stats-grid {
grid-template-columns: repeat(3, 1fr);
gap: 15px;
margin-bottom: 20px;
}
}
.stat-card {
background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
border-radius: 10px;
padding: 12px;
text-align: center;
}
@media (min-width: 768px) {
.stat-card {
padding: 15px;
}
}
.stat-label {
font-size: 0.8em;
color: #666;
margin-bottom: 5px;
line-height: 1.2;
}
@media (min-width: 768px) {
.stat-label {
font-size: 0.9em;
}
}
.stat-value {
font-size: 1.4em;
font-weight: bold;
color: #333;
}
@media (min-width: 768px) {
.stat-value {
font-size: 1.8em;
}
}
.sensors-grid {
display: grid;
grid-template-columns: 1fr;
gap: 15px;
margin-bottom: 15px;
}
@media (min-width: 768px) {
.sensors-grid {
grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
gap: 20px;
margin-bottom: 20px;
}
}
.sensor-card {
background: linear-gradient(135deg, #4a7c28 0%, #68a225 100%);
border-radius: 15px;
padding: 15px;
color: white;
box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
}
@media (min-width: 768px) {
.sensor-card {
padding: 20px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}
}
.sensor-card h3 {
margin-bottom: 12px;
font-size: 1.1em;
}
@media (min-width: 768px) {
.sensor-card h3 {
margin-bottom: 15px;
font-size: 1.2em;
}
}
.water-level-display {
font-size: 2em;
font-weight: bold;
margin: 12px 0;
text-align: center;
line-height: 1;
}
@media (min-width: 768px) {
.water-level-display {
font-size: 2.5em;
margin: 15px 0;
}
}
.tank-visual {
width: 100%;
height: 100px;
background: rgba(255,255,255,0.2);
border-radius: 8px;
position: relative;
overflow: hidden;
margin: 12px 0;
}
@media (min-width: 768px) {
.tank-visual {
height: 120px;
border-radius: 10px;
margin: 15px 0;
}
}
.water-fill {
position: absolute;
bottom: 0;
width: 100%;
background: linear-gradient(180deg, #4fc3f7 0%, #29b6f6 100%);
transition: height 1s ease;
display: flex;
align-items: center;
justify-content: center;
color: white;
font-weight: bold;
font-size: 14px;
}
.sensor-info {
display: flex;
justify-content: space-between;
font-size: 0.8em;
opacity: 0.9;
flex-wrap: wrap;
gap: 8px;
}
@media (min-width: 768px) {
.sensor-info {
font-size: 0.9em;
flex-wrap: nowrap;
gap: 0;
}
}
.history-section {
background: white;
border-radius: 15px;
padding: 15px;
margin-bottom: 15px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
@media (min-width: 768px) {
.history-section {
padding: 20px;
margin-bottom: 20px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}
}
.history-section h3 {
margin-bottom: 12px;
color: #333;
font-size: 1.1em;
}
@media (min-width: 768px) {
.history-section h3 {
margin-bottom: 15px;
font-size: 1.2em;
}
}
.history-table {
width: 100%;
max-height: 250px;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
border-radius: 8px;
border: 1px solid #ddd;
}
@media (min-width: 768px) {
.history-table {
max-height: 300px;
}
}
.history-table table {
width: 100%;
border-collapse: collapse;
font-size: 14px;
}
@media (min-width: 768px) {
.history-table table {
font-size: 16px;
}
}
.history-table th {
background: #4a7c28;
color: white;
padding: 8px 6px;
text-align: left;
position: sticky;
top: 0;
font-size: 12px;
white-space: nowrap;
}
@media (min-width: 768px) {
.history-table th {
padding: 10px;
font-size: 14px;
}
}
.history-table td {
padding: 6px;
border-bottom: 1px solid #ddd;
font-size: 12px;
white-space: nowrap;
}
@media (min-width: 768px) {
.history-table td {
padding: 8px;
font-size: 14px;
}
}
.message-log {
background: #f8f9fa;
border-radius: 10px;
padding: 12px;
margin-top: 15px;
max-height: 150px;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
}
@media (min-width: 768px) {
.message-log {
padding: 15px;
margin-top: 20px;
max-height: 200px;
}
}
.message-log h3 {
margin-bottom: 8px;
color: #333;
font-size: 1em;
}
@media (min-width: 768px) {
.message-log h3 {
margin-bottom: 10px;
font-size: 1.1em;
}
}
.log-entry {
font-family: monospace;
font-size: 11px;
padding: 4px;
border-bottom: 1px solid #ddd;
word-wrap: break-word;
line-height: 1.3;
}
@media (min-width: 768px) {
.log-entry {
font-size: 12px;
padding: 5px;
}
}
.footer-info {
text-align: center;
color: #666;
font-size: 0.8em;
margin-top: 15px;
line-height: 1.4;
}
@media (min-width: 768px) {
.footer-info {
font-size: 0.9em;
margin-top: 20px;
}
}
.error-notice {
background: #f8d7da;
color: #721c24;
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
display: none;
font-size: 14px;
}
@media (min-width: 768px) {
.error-notice {
padding: 15px;
margin-bottom: 20px;
font-size: 16px;
}
}
.map-container {
background: white;
border-radius: 15px;
padding: 12px;
margin-bottom: 15px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
position: relative;
}
@media (min-width: 768px) {
.map-container {
padding: 20px;
margin-bottom: 20px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}
}
.map-container h3 {
margin-bottom: 12px;
color: #333;
font-size: 1.1em;
}
@media (min-width: 768px) {
.map-container h3 {
margin-bottom: 15px;
font-size: 1.2em;
}
}
#leafletMap {
width: 100%;
height: 400px;
border-radius: 10px;
z-index: 1;
}
@media (min-width: 768px) {
#leafletMap {
height: 500px;
}
}
.leaflet-popup-content {
text-align: center;
font-weight: bold;
}
.sensor-marker {
background: white;
border: 3px solid #4a7c28;
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
font-weight: bold;
color: #4a7c28;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
font-size: 16px;
}
.sensor-level-label {
background: white;
border: 2px solid #4a7c28;
border-radius: 5px;
padding: 4px 8px;
text-align: center;
font-size: 12px;
font-weight: bold;
color: #2d5016;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
white-space: nowrap;
}
.info-notice {
background: #cce5ff;
color: #004085;
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
font-size: 14px;
}
@media (min-width: 768px) {
.info-notice {
padding: 15px;
margin-bottom: 20px;
font-size: 16px;
}
}
/* --- Shared Chat (MQTT-backed) --- */
.chat-widget{
 position:fixed;
 right:20px;
 bottom:20px;
 width:min(360px, 92%);
 height:450px;
 z-index:50;
 display:flex;
 flex-direction:column;
 background: rgba(255,255,255,0.96);
 border: 2px solid rgba(74,124,40,0.45);
 border-radius: 14px;
 box-shadow: 0 10px 26px rgba(0,0,0,0.25);
 overflow:hidden;
 backdrop-filter: blur(6px);
}
.chat-header{
 display:flex;
 align-items:center;
 justify-content:space-between;
 gap:8px;
 padding:10px 12px;
 background: linear-gradient(135deg, rgba(74,124,40,0.95) 0%, rgba(104,162,37,0.95) 100%);
 color:#fff;
 font-weight:700;
 font-size:13px;
}
.chat-header small{ font-weight:600; opacity:0.9; }
.chat-feed{
 flex:1;
 padding:10px 12px;
 overflow:auto;
 background: rgba(255,255,255,0.92);
}
.chat-msg{
 margin:0 0 8px 0;
 padding:8px 10px;
 border-radius: 12px;
 border: 1px solid rgba(0,0,0,0.08);
 background: rgba(245,247,250,0.95);
}
.chat-msg .meta{
 display:flex;
 gap:8px;
 align-items:baseline;
 flex-wrap:wrap;
 margin-bottom:4px;
 font-size:11px;
 color:#555;
}
.chat-msg .meta .who{ font-weight:700; color:#2d5016; }
.chat-msg .meta .kind{
 font-weight:800;
 font-size:10px;
 padding:2px 6px;
 border-radius: 999px;
 border:1px solid rgba(74,124,40,0.25);
 color:#2d5016;
 background: rgba(212,244,221,0.55);
}
.chat-msg .body{
 font-size:13px;
 color:#222;
 line-height:1.25;
 word-wrap:break-word;
}
.chat-compose{
 display:grid;
 grid-template-columns: 1fr 110px;
 gap:8px;
 padding:10px 12px;
 background: rgba(248,249,250,0.95);
 border-top:1px solid rgba(0,0,0,0.08);
}
.chat-compose input, .chat-compose select{
 padding:10px;
 border-radius:10px;
 border:1px solid rgba(0,0,0,0.18);
 font-size:13px;
}
.chat-compose .row2{
 grid-column: 1 / -1;
 display:grid;
 grid-template-columns: 1fr 110px;
 gap:8px;
}
.chat-compose button{
 min-width:110px;
 padding:10px 12px;
 border-radius:10px;
 font-size:13px;
 min-height:auto;
}
.chat-hint{
 padding:8px 12px;
 font-size:11px;
 color:#666;
 background: rgba(255,255,255,0.85);
 border-top:1px dashed rgba(0,0,0,0.12);
}
@media (max-width: 480px){
 .chat-widget{ height:400px; right:10px; bottom:10px; }
}
</style>
</head>
<body>
<div class="container">
<h1>üåä Flash Flood Watch POC</h1>
<div id="status" class="status disconnected">Not Connected</div>
<div id="loadingNotice" class="loading-notice">
Loading MQTT library... Please wait...
</div>
<div id="errorNotice" class="error-notice"></div>
<div class="config-section">
<h3>MQTT Configuration</h3>
<div class="button-group">
<button class="preset-btn" onclick="setPreset('emqx')">EMQX Public</button>
<button class="preset-btn" onclick="setPreset('mosquitto')">Test Mosquitto (Secure)</button>
<button class="preset-btn" onclick="setPreset('hivemq')">HiveMQ Public</button>
</div>
<br>
<div class="config-grid">
<input type="text" id="broker" placeholder="Broker URL" value="broker.emqx.io">
<input type="text" id="port" placeholder="Port" value="8084">
<input type="text" id="topic" placeholder="Topic" value="msh/US/2/json/#">
<input type="text" id="chatTopic" placeholder="Chat Topic Base" value="waterlevel/chat">
<select id="maxPoints">
<option value="50">Keep last 50 readings</option>
<option value="100" selected>Keep last 100 readings</option>
<option value="200">Keep last 200 readings</option>
</select>
</div>
<div class="button-group">
<button id="connectBtn" onclick="connectMQTT()" disabled>Connect</button>
<button id="disconnectBtn" onclick="disconnectMQTT()" style="display:none;">Disconnect</button>
<button class="export-btn" onclick="exportData()">Export CSV</button>
<button class="clear-btn" onclick="clearData()">Clear Data</button>
</div>
</div>
<!-- HISTORY TABLE - NOW WITH 3 COLUMNS -->
<div class="history-section">
<h3>Recent Readings</h3>
<div class="history-table">
<table>
<thead>
<tr>
<th>Time</th>
<th>Sensor 1 (ft)</th>
<th>Sensor 2 (ft)</th>
<th>Sensor 3 (ft)</th>
</tr>
</thead>
<tbody id="historyTableBody">
<tr><td colspan="4" style="text-align:center;">No data yet</td></tr>
</tbody>
</table>
</div>
</div>
<!-- MAP - NOW WITH 3 SENSOR MARKERS -->
<div class="map-container">
<h3>üìç Sensor Locations - Morro Bay, CA</h3>
<div id="leafletMap"></div>
</div>
<!-- Shared Chat (visible to all dashboard users) -->
<div class="chat-widget" id="chatWidget" aria-label="Emergency coordination chat">
 <div class="chat-header">
 <div>üì° Ops Chat <small id="chatConn">‚Ä¢ offline</small></div>
 <small id="chatRoomLabel">waterlevel/chat</small>
 </div>
 <div class="chat-feed" id="chatFeed">
 <div class="chat-msg">
 <div class="meta"><span class="who">System</span> <span class="kind">INFO</span></div>
 <div class="body">Chat loads when MQTT connects. Use this for coordination, status updates, and action logs.</div>
 </div>
 </div>
 <div class="chat-compose">
 <input id="chatName" type="text" placeholder="Your name (e.g., Unit 12)" onblur="saveChatName()">
 <select id="chatKind" aria-label="Message type">
 <option value="COORD">Coordination</option>
 <option value="STATUS">Status</option>
 <option value="ACTION">Action Log</option>
 </select>
 <div class="row2">
 <input id="chatText" type="text" placeholder="Type a message‚Ä¶" maxlength="280">
 <button id="chatSendBtn" onclick="sendChatMessage()" disabled>Send</button>
 </div>
 </div>
 <div class="chat-hint">Everyone connected to the same broker & chat topic sees the same feed (MQTT retained history).</div>
</div>
</div>
<div class="message-log">
<h3>Message Log</h3>
<div id="messageLog">
<div class="log-entry">Waiting for MQTT library to load...</div>
</div>
</div>
<div class="footer-info">
Last Update: <span id="lastUpdate">Never</span> |
Total Readings: <span id="totalReadings">0</span>
</div>
</div>
<!-- MQTT Library from CDN -->
<script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
<!-- Leaflet Library -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
// Global variables - NOW WITH 3 SENSORS
let chatMsgTopic = null;
let chatHistoryTopic = null;
let chatHistory = [];
const CHAT_HISTORY_LIMIT = 60;
let client = null;
let sensor1Data = { from: null, history: [], nodeId: null, min: null, max: null };
let sensor2Data = { from: null, history: [], nodeId: null, min: null, max: null };
let sensor3Data = { from: null, history: [], nodeId: null, min: null, max: null };
let maxDataPoints = 100;
const MAX_TANK_HEIGHT = 10; // feet
let mqttAvailable = false;
let autoConnectTriggered = false;
const isHTTPS = window.location.protocol === 'https:';

// Leaflet map variables
let leafletMap = null;
let mapMarkers = {};
let mapLabels = {};
const sensorLocations = {
  1: { lat: 35.3648941, lng: -120.8533490, name: 'Sensor 1 (North)' },
  2: { lat: 35.3467186, lng: -120.8446550, name: 'Sensor 2 (Central)' },
  3: { lat: 35.3213325, lng: -120.8530389, name: 'Sensor 3 (South)' }
};

// Initialize Leaflet map
function initLeafletMap() {
  leafletMap = L.map('leafletMap').setView([35.3450, -120.8490], 13);
  
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(leafletMap);
  
  // Create custom markers with permanent labels
  for (let i = 1; i <= 3; i++) {
    const loc = sensorLocations[i];
    
    // Create numbered circle marker
    const customIcon = L.divIcon({
      className: 'custom-marker',
      html: `<div class="sensor-marker">${i}</div>`,
      iconSize: [36, 36],
      iconAnchor: [18, 18]
    });
    
    const marker = L.marker([loc.lat, loc.lng], { icon: customIcon }).addTo(leafletMap);
    mapMarkers[i] = marker;
    
    // Create permanent label below marker showing water level
    const labelIcon = L.divIcon({
      className: 'sensor-label',
      html: `<div class="sensor-level-label" id="map-level-${i}">-- ft</div>`,
      iconSize: [60, 24],
      iconAnchor: [30, -10]
    });
    
    const label = L.marker([loc.lat, loc.lng], { icon: labelIcon, interactive: false }).addTo(leafletMap);
    mapLabels[i] = label;
  }
}

// Update map marker label
function updateMapMarker(num, level) {
  const labelEl = document.getElementById(`map-level-${num}`);
  if (labelEl) {
    labelEl.textContent = `${level.toFixed(1)} ft`;
  }
}
function loadMQTTFallback() {
const script = document.createElement('script');
script.src = 'https://cdn.jsdelivr.net/npm/mqtt@4.3.7/dist/mqtt.min.js';
script.onload = function() {
checkMQTT();
};
script.onerror = function() {
showError('Unable to load MQTT library. Please check your internet connection.');
document.getElementById('loadingNotice').style.display = 'none';
};
document.head.appendChild(script);
}
function checkMQTT() {
if (typeof mqtt !== 'undefined') {
mqttAvailable = true;
document.getElementById('connectBtn').disabled = false;
document.getElementById('loadingNotice').style.display = 'none';
addLog('MQTT library loaded successfully');
addLog('Ready to connect to MQTT broker');
if (isHTTPS) {
addLog('Running on HTTPS - using secure WebSocket (WSS)');
}
if (!autoConnectTriggered && !client) {
autoConnectTriggered = true;
addLog('Auto-connecting to default broker...');
setTimeout(connectMQTT, 1000);
}
} else {
setTimeout(loadMQTTFallback, 1000);
}
}
window.addEventListener('load', function() {
 loadChatPrefs();
 initLeafletMap();
 setTimeout(checkMQTT, 500);
});
// --- Shared Chat helpers ---
function sanitizeText(s){ return (s || '').toString().replace(/[\u0000-\u001f]/g,'').trim(); }
function escapeHtml(str){
 return (str || '').toString()
 .replaceAll('&','&amp;')
 .replaceAll('<','&lt;')
 .replaceAll('>','&gt;')
 .replaceAll('"','&quot;')
 .replaceAll("'",'&#39;');
}
function loadChatPrefs(){
 const savedName = localStorage.getItem('wlm_chat_name') || '';
 if (savedName && document.getElementById('chatName')) {
 document.getElementById('chatName').value = savedName;
 }
}
function saveChatName(){
 const v = sanitizeText(document.getElementById('chatName')?.value);
 localStorage.setItem('wlm_chat_name', v);
}
function setChatConnectionLabel(isOnline){
 const el = document.getElementById('chatConn');
 if (!el) return;
 el.textContent = isOnline ? '‚Ä¢ online' : '‚Ä¢ offline';
 el.style.opacity = isOnline ? '1' : '0.85';
}
function setChatRoomLabel(base){
 const label = document.getElementById('chatRoomLabel');
 if (label) label.textContent = base;
}
function ensureChatTopics(){
 const base = sanitizeText(document.getElementById('chatTopic')?.value) || 'waterlevel/chat';
 chatMsgTopic = `${base}/msg`;
 chatHistoryTopic = `${base}/history`;
 setChatRoomLabel(base);
 return base;
}
function mergeChatMessage(msg){
 if (!msg || !msg.ts || !msg.text) return false;
 const key = `${msg.ts}|${msg.user||''}|${msg.kind||''}|${msg.text||''}`;
 if (!mergeChatMessage._seen) mergeChatMessage._seen = new Set();
 if (mergeChatMessage._seen.has(key)) return false;
 mergeChatMessage._seen.add(key);
 chatHistory.push({
 ts: msg.ts,
 user: (msg.user || '').toString().slice(0, 32),
 kind: (msg.kind || '').toString().slice(0, 12),
 text: (msg.text || '').toString().slice(0, 280)
 });
 if (chatHistory.length > CHAT_HISTORY_LIMIT) {
 chatHistory = chatHistory.slice(-CHAT_HISTORY_LIMIT);
 }
 return true;
}
function renderChat(){
 const feed = document.getElementById('chatFeed');
 if (!feed) return;
 feed.innerHTML = '';
 const items = (chatHistory || []).slice(-CHAT_HISTORY_LIMIT);
 if (!items.length){
 const empty = document.createElement('div');
 empty.className = 'chat-msg';
 empty.innerHTML = '<div class="meta"><span class="who">System</span> <span class="kind">INFO</span></div><div class="body">No messages yet.</div>';
 feed.appendChild(empty);
 return;
 }
 for (const m of items){
 const div = document.createElement('div');
 div.className = 'chat-msg';
 const when = m.ts ? new Date(m.ts).toLocaleTimeString() : '';
 const who = (m.user || 'Unknown').toString().slice(0, 32);
 const kind = (m.kind || 'MSG').toString().slice(0, 12);
 const body = (m.text || '').toString();
 div.innerHTML = `
 <div class="meta">
 <span class="who">${escapeHtml(who)}</span>
 <span class="kind">${escapeHtml(kind)}</span>
 <span class="when">${escapeHtml(when)}</span>
 </div>
 <div class="body">${escapeHtml(body)}</div>
 `;
 feed.appendChild(div);
 }
 feed.scrollTop = feed.scrollHeight;
}
function publishChatHistoryRetained(){
 if (!client || !chatHistoryTopic) return;
 try{
 const payload = JSON.stringify({ v: 1, items: chatHistory.slice(-CHAT_HISTORY_LIMIT) });
 client.publish(chatHistoryTopic, payload, { retain: true, qos: 0 });
 } catch(e){}
}
function sendChatMessage(){
 if (!client || !chatMsgTopic) return;
 const user = sanitizeText(document.getElementById('chatName')?.value) || 'Unknown';
 const kind = sanitizeText(document.getElementById('chatKind')?.value) || 'COORD';
 const textEl = document.getElementById('chatText');
 const text = sanitizeText(textEl?.value);
 if (!text) return;
 const msg = { ts: Date.now(), user, kind, text };
 saveChatName();
 try{
 client.publish(chatMsgTopic, JSON.stringify(msg), { qos: 0 });
 } catch(e){}
 if (mergeChatMessage(msg)){
 renderChat();
 publishChatHistoryRetained();
 }
 if (textEl) textEl.value = '';
}
function setPreset(preset) {
const configs = {
mosquitto: {
broker: 'test.mosquitto.org',
port: '8081',
topic: 'msh/US/2/json/#'
},
hivemq: {
broker: 'broker.hivemq.com',
port: '8884',
topic: 'msh/US/2/json/#'
},
emqx: {
broker: 'broker.emqx.io',
port: '8084',
topic: 'msh/US/2/json/#'
}
};
if (configs[preset]) {
document.getElementById('broker').value = configs[preset].broker;
document.getElementById('port').value = configs[preset].port;
document.getElementById('topic').value = configs[preset].topic;
addLog(`Preset: ${preset} selected (secure connection)`);
}
}
function connectMQTT() {
if (!mqttAvailable || typeof mqtt === 'undefined') {
alert('MQTT library not loaded. Please refresh the page.');
return;
}
try {
const broker = document.getElementById('broker').value;
let port = document.getElementById('port').value;
const topic = document.getElementById('topic').value;
maxDataPoints = parseInt(document.getElementById('maxPoints').value);
if (!broker || !port) {
alert('Please enter broker and port');
return;
}
document.getElementById('status').className = 'status connecting';
document.getElementById('status').textContent = 'Connecting...';
if (client) {
client.end();
}
let protocol = 'wss';
if (!isHTTPS && (port === '8080' || port === '1883')) {
protocol = 'ws';
} else {
protocol = 'wss';
if (port === '8080') {
port = '8081';
addLog('Auto-corrected port 8080 to 8081 for secure connection');
document.getElementById('port').value = '8081';
} else if (port === '1883') {
port = '8883';
addLog('Auto-corrected port 1883 to 8883 for secure connection');
document.getElementById('port').value = '8883';
}
}
const url = `${protocol}://${broker}:${port}/mqtt`;
addLog(`Connecting to ${url} (${protocol.toUpperCase()})`);
client = mqtt.connect(url, {
clientId: 'water-' + Math.random().toString(16).substr(2, 8),
clean: true,
connectTimeout: 10000,
reconnectPeriod: 5000
});
client.on('connect', function() {
document.getElementById('status').className = 'status connected';
document.getElementById('status').textContent = `Connected to ${broker}:${port}`;
document.getElementById('connectBtn').style.display = 'none';
document.getElementById('disconnectBtn').style.display = 'inline-block';
client.subscribe(topic, function(err) {
if (!err) {
addLog(`Subscribed to: ${topic}`);
addLog('Waiting for water sensor messages...');
// Join shared chat (retained history so new viewers see prior messages)
const chatBase = ensureChatTopics();
setChatConnectionLabel(true);
document.getElementById('chatSendBtn').disabled = false;
client.subscribe([chatMsgTopic, chatHistoryTopic], function(chatErr) {
 if (!chatErr) {
 addLog(`Chat subscribed: ${chatBase}`);
 } else {
 addLog(`Chat subscribe error: ${chatErr.message || chatErr}`);
 }
});
} else {
addLog(`Subscribe error: ${err.message}`);
}
});
});
client.on('message', function(topic, message) {
try {
 const raw = message.toString();
 // Chat: retained history (shared)
 if (chatHistoryTopic && topic === chatHistoryTopic) {
 try {
 const payload = JSON.parse(raw);
 if (payload && Array.isArray(payload.items)) {
 chatHistory = payload.items.slice(-CHAT_HISTORY_LIMIT);
 renderChat();
 }
 } catch (e) {}
 return;
 }
 // Chat: single message
 if (chatMsgTopic && topic === chatMsgTopic) {
 try {
 const msg = JSON.parse(raw);
 if (mergeChatMessage(msg)) {
 renderChat();
 }
 } catch (e) {}
 return;
 }
 // Existing Meshtastic sensor parsing
 const data = JSON.parse(raw);
if (data.type === 'text' && data.payload && data.payload.text) {
const text = data.payload.text;
addLog(`Topic: ${topic}`);
addLog(`Message: ${text}`);
let match = text.match(/([\d.]+)\s*feet/i) ||
text.match(/([\d.]+)\s*ft/i) ||
text.match(/Level:\s*([\d.]+)/i);
let cpuMatch = text.match(/CPU:\s*([\d.]+)¬∞C/i);
if (match) {
const level = parseFloat(match[1]);
const cpu = cpuMatch ? parseFloat(cpuMatch[1]) : null;
const nodeId = topic.split('/').pop();
// Fixed node number to sensor mapping
const nodeNum = data.from;
if (nodeNum === 2375489073) {
updateSensor(1, level, cpu, nodeId);
} else if (nodeNum === 1507621382) {
updateSensor(2, level, cpu, nodeId);
} else if (nodeNum === 3429578941) {
updateSensor(3, level, cpu, nodeId);
} else {
addLog(`Unknown node: ${nodeNum}`);
}
}
}
} catch (e) {
}
});
client.on('error', function(err) {
document.getElementById('status').className = 'status disconnected';
document.getElementById('status').textContent = 'Connection Error';
document.getElementById('connectBtn').style.display = 'inline-block';
document.getElementById('disconnectBtn').style.display = 'none';
let errorMsg = err.message || err;
if (errorMsg.includes('WebSocket') && isHTTPS) {
errorMsg += ' - Try using port 8081 (secure) instead of 8080';
}
addLog(`Error: ${errorMsg}`);
showError(errorMsg);
setChatConnectionLabel(false);
document.getElementById('chatSendBtn').disabled = true;
});
client.on('offline', function() {
document.getElementById('status').className = 'status disconnected';
document.getElementById('status').textContent = 'Offline';
setChatConnectionLabel(false);
document.getElementById('chatSendBtn').disabled = true;
});
} catch (e) {
console.error('Connection error:', e);
let errorMsg = e.message;
if (errorMsg.includes('WebSocket') && errorMsg.includes('insecure')) {
errorMsg = 'Security Error: Please use port 8081 for test.mosquitto.org or try HiveMQ preset';
}
showError(errorMsg);
setChatConnectionLabel(false);
document.getElementById('chatSendBtn').disabled = true;
}
}
function disconnectMQTT() {
if (client) {
client.end();
document.getElementById('status').className = 'status disconnected';
document.getElementById('status').textContent = 'Disconnected';
document.getElementById('connectBtn').style.display = 'inline-block';
document.getElementById('disconnectBtn').style.display = 'none';
addLog('Disconnected');
setChatConnectionLabel(false);
document.getElementById('chatSendBtn').disabled = true;
}
}
function updateSensor(num, level, cpu, nodeId) {
try {
const timestamp = new Date();
const sensorData = num === 1 ? sensor1Data : (num === 2 ? sensor2Data : sensor3Data);
const displayValue = Math.max(0, level);
if (sensorData.min === null || displayValue < sensorData.min) {
sensorData.min = displayValue;
}
if (sensorData.max === null || displayValue > sensorData.max) {
sensorData.max = displayValue;
}
sensorData.history.push({
time: timestamp,
level: displayValue,
cpu: cpu
});
if (sensorData.history.length > maxDataPoints) {
sensorData.history.shift();
}
updateHistoryTable();
// Update Leaflet map marker
updateMapMarker(num, displayValue);
document.getElementById('lastUpdate').textContent = timestamp.toLocaleTimeString();
document.getElementById('totalReadings').textContent =
sensor1Data.history.length + sensor2Data.history.length + sensor3Data.history.length;
} catch (e) {
console.error('Update sensor error:', e);
}
}
function updateHistoryTable() {
const tbody = document.getElementById('historyTableBody');
const combined = [
...sensor1Data.history.map(d => ({ t: d.time, s: 1, level: d.level })),
...sensor2Data.history.map(d => ({ t: d.time, s: 2, level: d.level })),
...sensor3Data.history.map(d => ({ t: d.time, s: 3, level: d.level })),
];
const bySec = new Map();
combined.forEach(d => {
if (!d || !d.t) return;
const key = Math.floor(new Date(d.t).getTime() / 1000);
if (!bySec.has(key)) bySec.set(key, { t: new Date(key * 1000), s1: null, s2: null, s3: null });
const row = bySec.get(key);
if (d.s === 1 && row.s1 == null) row.s1 = d.level;
if (d.s === 2 && row.s2 == null) row.s2 = d.level;
if (d.s === 3 && row.s3 == null) row.s3 = d.level;
});
const rowsArr = Array.from(bySec.values()).sort((a, b) => b.t - a.t).slice(0, 20);
const rows = rowsArr.map(r => `
<tr>
<td>${r.t.toLocaleTimeString()}</td>
<td>${r.s1 != null ? r.s1.toFixed(1) : ''}</td>
<td>${r.s2 != null ? r.s2.toFixed(1) : ''}</td>
<td>${r.s3 != null ? r.s3.toFixed(1) : ''}</td>
</tr>
`).join('');
tbody.innerHTML = rows || '<tr><td colspan="4" style="text-align:center;">No data yet</td></tr>';
}
function exportData() {
try {
const combined = [
...sensor1Data.history.map(d => ({ t: d.time, s: 1, level: d.level })),
...sensor2Data.history.map(d => ({ t: d.time, s: 2, level: d.level })),
...sensor3Data.history.map(d => ({ t: d.time, s: 3, level: d.level })),
];
const bySec = new Map();
combined.forEach(d => {
if (!d || !d.t) return;
const key = Math.floor(new Date(d.t).getTime() / 1000);
if (!bySec.has(key)) bySec.set(key, { t: new Date(key * 1000), s1: null, s2: null, s3: null });
const row = bySec.get(key);
if (d.s === 1 && row.s1 == null) row.s1 = d.level;
if (d.s === 2 && row.s2 == null) row.s2 = d.level;
if (d.s === 3 && row.s3 == null) row.s3 = d.level;
});
const rowsArr = Array.from(bySec.values()).sort((a, b) => a.t - b.t);
let csv = 'Timestamp,Sensor 1 (ft),Sensor 2 (ft),Sensor 3 (ft)\n';
rowsArr.forEach(r => {
const s1 = r.s1 != null ? r.s1.toFixed(2) : '';
const s2 = r.s2 != null ? r.s2.toFixed(2) : '';
const s3 = r.s3 != null ? r.s3.toFixed(2) : '';
csv += `${r.t.toISOString()},${s1},${s2},${s3}\n`;
});
const blob = new Blob([csv], { type: 'text/csv' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `water-levels-3sensors-${new Date().toISOString().split('T')[0]}.csv`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
addLog('Data exported to CSV');
} catch (e) {
console.error('Export error:', e);
showError('Export failed: ' + e.message);
}
}
function clearData() {
if (confirm('Clear all data? This cannot be undone.')) {
sensor1Data.history = [];
sensor1Data.min = null;
sensor1Data.max = null;
sensor2Data.history = [];
sensor2Data.min = null;
sensor2Data.max = null;
sensor3Data.history = [];
sensor3Data.min = null;
sensor3Data.max = null;
updateHistoryTable();
addLog('Data cleared');
}
}
function addLog(message) {
try {
const log = document.getElementById('messageLog');
const entry = document.createElement('div');
entry.className = 'log-entry';
entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
log.insertBefore(entry, log.firstChild);
while (log.children.length > 20) {
log.removeChild(log.lastChild);
}
} catch (e) {
console.error('Log error:', e);
}
}
function showError(message) {
const errorDiv = document.getElementById('errorNotice');
if (errorDiv) {
errorDiv.textContent = '‚ö† ' + message;
errorDiv.style.display = 'block';
setTimeout(() => {
errorDiv.style.display = 'none';
}, 10000);
}
console.error(message);
}
// Chat UX: press Enter to send (when focused in chat input)
document.addEventListener('keydown', (e) => {
 const active = document.activeElement;
 if (e.key === 'Enter' && active && active.id === 'chatText') {
 e.preventDefault();
 sendChatMessage();
 }
});
</script>
</body>
</html>
